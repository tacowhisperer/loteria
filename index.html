<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">

	<title>¡¡Lotería!!</title>

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

	<!-- Favicon -->
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
	<link rel="manifest" href="site.webmanifest">
	<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#00aba9">
	<meta name="theme-color" content="#ffffff">

	<style>
		@import url('https://fonts.googleapis.com/css2?family=Protest+Riot&display=swap');

		:root {
			--background-image-width: 1071px;
			--background-image-height: 1038px;

			/* I'm leaving these in here to remind myself to think before reinventing the wheel */
			--background-scroll-x: 200vw;
			--background-scroll-y: 200vh;
		}

		* {
			box-sizing: border-box;
		}

		html, body {
			margin: 0;
			padding: 0;

			/* No text elements should be selectable */
			user-select: none;

			/* Chrome makes taps look ugly on buttons that already have visual and haptic feedback */
			-webkit-tap-highlight-color: transparent;
		}

		body {
			background-color: black;
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			overflow: hidden;
		}

		@keyframes diagonalAnimation {
			0% { background-position: 0 0; }
			100% { background-position: var(--background-image-width) var(--background-image-height); }
		}

		#background {
			position: absolute;
			opacity: 0.3;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			transition: opacity 0.2s ease;

			background-image: url("real_esrgan_loteria.jpg");
			background-size: var(--background-image-width);
			animation: diagonalAnimation 360s linear infinite;

			z-index: -1000;
		}

		#background.inactive {
			opacity: 0.5;
		}

		#background.buenas {
			opacity: 0;
		}

		#victory_background {
			position: absolute;
			opacity: 0;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			transition: opacity 0.60s ease;

			background-image: url("money-tree.jpg");
			background-size: cover;
			background-position: 50% 50%;
			z-index: -999;

			display: flex;
			justify-content: center;
			align-items: center;
		}

		#victory_background.buenas {
			opacity: 1;
		}

		#victory_background > p {
			font-family: 'Protest Riot', sans-serif;
			font-size: 14.5vw;
			color: #f0f0f0;
			text-shadow: 0 0 2.5vh #ccb000;
			letter-spacing: -0.35rem;
			height: 100vh;
			line-height: 100vh;
			transform: rotate(-12deg);

			position: relative;
		}

		#victory_background > p::before {
			content: "";
			position: absolute;
			width: 100%;
			height: 100%;
			top: -2%;
			left: 0%;
			z-index: -1;

			background-image: url("gold-paint.png");
			background-size: contain;
			background-repeat: no-repeat;
			background-position: center;
			transform: rotate(20deg);
		}

		#carta {
			background: url("back.png");
			background-position: center;
			background-size: 100% 100%;

			border: 1.5vh solid black;
			border-radius: 2vh;
			opacity: 1;
			height: 58.42vh; /* includes 2*border width due to box-sizing CSS */
			width: 40.06vh; /* includes 2*border width due to box-sizing CSS */

			cursor: pointer;
			transition: transform 0.025s ease, opacity 0.60s ease;
			-webkit-tap-highlight-color: transparent;

			display: flex;
			align-items: center;
			justify-content: center;

			z-index: 0;
		}

		#carta.flipped {
			transform: scaleX(0);
			transition: transform 0.1s ease;
		}

		#state_text {
			font-family: 'Protest Riot', sans-serif;
			font-size: 10vh;
			color: #f0f0f0;
			opacity: 1;
			text-shadow: 0.6vh 0.6vh 0 #333, 0.6vh -0.6vh 0 #333, -0.6vh 0.6vh 0 #333, -0.6vh -0.6vh 0 #333, 0.8485vh 0 0 #333, -0.8485vh 0 0 #333, 0 0.8485vh 0 #333, 0 -0.8485vh 0 #333, 0.7839vh 0.3247vh 0 #333, -0.7839vh 0.3247vh 0 #333, 0.7839vh -0.3247vh 0 #333, -0.7839vh -0.3247vh 0 #333, 0.3247vh 0.7839vh 0 #333, -0.3247vh 0.7839vh 0 #333, 0.3247vh -0.7839vh 0 #333, -0.3247vh -0.7839vh 0 #333;
			transform: rotate(-12deg);
			transition: opacity 0.1s ease, translate 0.1s ease;
		}

		#carta.clicked {
			scale: 1.05;
		}

		#carta.buenas {
			cursor: default;
			opacity: 0;
		}

		#history {
			height: 70vh;
			width: 8.72vh;
			opacity: 1;

			position: absolute;
			right: 1.5vw;

			transition: opacity 0.60s ease;
		}

		#history.buenas {
			opacity: 0;
		}

		#history > div {
			box-sizing: content-box;

			border: 2px solid black;
			border-radius: 5px;
			height: 13.04vh;
			width: 8.72vh;

			position: absolute;
			display: none;
		}

		#card_count {
			background-color: rgba(0, 0, 0, 0.5);
			color: white;
			border: none;
			border-radius: 1vh;

			font-family: 'Protest Riot', sans-serif;
			font-size: 2vh;
			text-align: center;
			position: absolute;

			transform: translate(14vh, -26vh);
		}

		#card_count.counting {
			padding: 0.2vh 1vh;
		}

		.nav_button {
			background-size: contain;
			background-position: center;
			cursor: pointer;
			overflow: hidden;
			height: 10vh;
			width: 10vh;
			position: fixed;
			transition: transform 0.1s ease, opacity 0.2s ease;
			z-index: 1;
		}

		#buenas {
			background-image: url("coins-29899.svg");
			transform: translate(-6.5vw, 55vh);
		}

		#buenas.clicked {
			transform: translate(-6.5vw, 37.5vh) scale(1.1);
		}

		#buenas.alto {
			transform: translate(-6.5vw, 37vh);
		}

		#siguiente {
			border-radius: 50%;
			background-image: url("next-svgrepo-com.svg");
			transform: translate(-6.5vw, 37vh);
			opacity: 1;
		}

		#siguiente.clicked {
			transform: translate(-6.5vw, 37.5vh) scale(1.1);
		}

		#siguiente.inactive {
			display: none;
			opacity: 0;
		}

		#siguiente.alto {
			transform: translate(-6.5vw, 55vh);
		}

		#siguiente_timer {
			position: absolute;
			height: 100%;
			width: 100%;

			mask-image: radial-gradient(circle at center, transparent 48%, black 50%);
		}

		.hidden {
			display: none;
		}

		#spacer {
			width: 0;
			transition: width 0.25s ease;
		}

		#spacer.playing {
			width: 13vw;
		}

		#container {
			height: 100vh;
			width: 100vw;

			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: center;
			align-items: center;

			overflow: hidden;
		}

		#loading {
			border: 1vh solid white;
			border-top: 1vh solid #333;
			border-radius: 50%;
			height: 10vh;
			width: 10vh;
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		.removed {
			display: none !important;
		}

		#menu_btn_container {
			position: fixed;

			padding: 1.5rem;

			top: 0;
			left: 0;
			z-index: 3;
		}

		#menu_btn.inactive {
			display: flex;
		}

		#menu_btn {
			display: none;
			flex-direction: column;
			cursor: pointer;
		}

		.hamburger_bar {
			background-color: #eee;
			border-radius: 0.5rem;
			width: 3.5rem;
			height: 0.5rem;
			margin: 0.3rem 0;
			transition: 0.1s;
		}

		.change .hamburger_bar:nth-child(1) {
			transform: translate(0, 1.07rem) rotate(-45deg);
		}

		.change .hamburger_bar:nth-child(2) {
			transform: scaleX(0);
			opacity: 0;
		}

		.change .hamburger_bar:nth-child(3) {
			transform: translate(0, -1.07rem) rotate(45deg);
		}

		#menu_ribbon {
			display: flex;
			position: fixed;
			background-color: rgba(0, 0, 0, 0.65);
			color: #eee;
			font-family: 'Protest Riot', sans-serif;
			font-size: 1.5em;
			top: 0;
			left: 0;
			overflow-y: scroll;
			padding-top: 10rem;
			padding-bottom: 10rem;
			height: 100vh;
			width: min(100vw, 100vh);
			transform: translate(-100%, 0);
			transition: 0.1s ease;
			z-index: 2;
		}

		#menu_ribbon > * {
			margin-left: 0.75rem;
			margin-top: 0.5rem;
			margin-bottom: 0.5rem;
		}

		#menu_ribbon.engaged {
			transform: translate(0, 0);
		}

		#menu_container {
			list-style-type: none;
			width: 100%;
		}

		.menu_option {
			display: flex;
			flex-wrap: wrap;
			justify-content: flex-start;
			column-gap: 2rem;
			align-items: center;
			align-content: center;
		}

		.menu_option + .menu_option {
			margin-top: 4rem;
			padding-top: 4rem;
			border-top: 1px solid;
			border-image: linear-gradient(to right, #d80b77, transparent) 1 0 0 0;
		}

		#menu_overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 1;
		}

		#menu_overlay.engaged {
			display: block;
		}

		/* Chrome, Safari, Edge, Opera */
		input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		/* Firefox */
		input[type=number] {
			-moz-appearance: textfield;
		}

		input {
			aspect-ratio: 1 / 1;
			color: #eee;
			display: block;
			background-color: black;
			border: none;
			border-radius: 1rem;
			font-family: 'Protest Riot', sans-serif;
			font-size: 1.25em;
			text-align: center;
			padding: 1rem;
			height: 5rem;
		}
	</style>
</head>
<body>

<div id="container">
	<div id="menu_btn_container" class="removed">
		<div id="menu_btn">
			<div class="hamburger_bar"></div>
			<div class="hamburger_bar"></div>
			<div class="hamburger_bar"></div>
		</div>
	</div>

	<div id="menu_ribbon" class="removed">
		<ul id="menu_container">
			<!-- <li class="menu_option"><p>Tamaño de Historial:</p><div style="height: 3rem; width: 3rem; background-color: white;"></div></li>
			<li class="menu_option"><p>Reproducir Sonidos:</p><div style="height: 3rem; width: 3rem; background-color: blue;"></div></li> -->
		</ul>
	</div>

	<div id="menu_overlay" class="removed"></div>

	<div id="carta" class="removed">
		<p id="state_text">¡Ámonos!</p>
		<p id="card_count"></p>
	</div>

	<!-- Spacing for the history div -->
	<div id="spacer" class="removed"></div>

	<div id="history" class="removed">
	</div>

	<div id="siguiente" class="removed nav_button inactive">
		<div id="siguiente_timer"></div>
	</div>

	<div id="buenas" class="removed nav_button"></div>

	<div id="background" class="removed"></div>

	<div id="victory_background" class="removed">
		<p>✨¡BUENAS!✨</p>
	</div>

	<div id="loading"></div>
</div>

<script>
const container = document.getElementById("container");

const loteriaImg = new Image();
loteriaImg.src = 'loteria.jpg';

const barajaImg = new Image();
barajaImg.src = 'back.png';

const backgroundImg = new Image();
backgroundImg.src = 'real_esrgan_loteria.jpg';

const buenasImg = new Image();
buenasImg.src = 'money-tree.jpg';

const resetImg = new Image();
resetImg.src = 'refresh-circle-svgrepo-com.svg';

const nextImg = new Image();
nextImg.src = 'next-svgrepo-com.svg';

const images = [loteriaImg, barajaImg, backgroundImg, buenasImg, resetImg, nextImg];

const loadLoop = setInterval(() => {
	const imagesLoaded = images.reduce((bool, img) => img.complete && bool, true);

	if (imagesLoaded) {
		clearInterval(loadLoop);

		// Unhide any manually removed elements that may have used required images above as backgrounds and hide the loading spinner
		[...container.children].map(e => e.classList.toggle("removed"));

		loadApp();
	}
}, 25);

function loadApp() {
	// Baraja theme colors
	const YELLOW = '220, 180, 10';
	const LIGHT_YELLOW = '250, 220, 100';
	const BLUE = '10, 175, 220';
	const RED = '220, 20, 10';
	const MAGENTA = '220, 10, 220';
	const GREEN = '10, 175, 10';
	const WHITE = '250, 250, 250';
	const BLACK = '0, 0, 0';
	const PINK = '235, 60, 165';
	const SALMON = '240, 125, 190';
	const SKIN = '240, 145, 125';
	const SCARLET = '235, 5, 5';
	const BROWN = '195, 55, 5';
	const DARK_BROWN = '110, 50, 0';

	const loteriaDeck = [
		["El Gallo", [BLUE, GREEN]],
		["El Diablito", [YELLOW, RED]],
		["La Dama", [SALMON, BLUE]],
		["El Catrín", [LIGHT_YELLOW, SALMON]],
		["El Paraguas", [BLACK, BLUE]],
		["La Sirena", [BLUE, RED]],
		["La Escalera", [PINK, BLUE]],
		["La Botella", [SALMON, RED]],
		["El Barril", [YELLOW, GREEN]],
		["El Árbol", [SALMON, GREEN]],
		["El Melón", [BLUE, SKIN]],
		["El Valiente", [SALMON, BLUE]],
		["El Gorrito", [LIGHT_YELLOW, RED]],
		["La Muerte", [SALMON, YELLOW]],
		["La Pera", [BLUE, GREEN]],
		["La Bandera", [LIGHT_YELLOW, GREEN]],
		["El Bandolón", [BLUE, LIGHT_YELLOW]],
		["El Violoncello", [WHITE, YELLOW]],
		["La Garza", [BLUE, GREEN]],
		["El Pájaro", [RED, YELLOW]],
		["La Mano", [SKIN, BLUE]],
		["La Bota", [BLACK, YELLOW]],
		["La Luna", [BLUE, WHITE]],
		["El Cotorro", [SCARLET, GREEN]],
		["El Borracho", [LIGHT_YELLOW, SALMON]],
		["El Negrito", [LIGHT_YELLOW, BLUE]],
		["El Corazón", [LIGHT_YELLOW, RED]],
		["La Sandía", [PINK, GREEN]],
		["El Tambor", [BLUE, YELLOW]],
		["El Camarón", [YELLOW, RED]],
		["Las Jaras", [BLUE, YELLOW]],
		["El Músico", [YELLOW, BLUE]],
		["La Araña", [BLACK, BLUE]],
		["El Soldado", [YELLOW, SALMON]],
		["La Estrella", [WHITE, BLUE]],
		["El Cazo", [SCARLET, LIGHT_YELLOW]],
		["El Mundo", [BLUE, LIGHT_YELLOW]],
		["El Apache", [LIGHT_YELLOW, SKIN]],
		["El Nopal", [GREEN, BLUE]],
		["El Alacrán", [BLACK, LIGHT_YELLOW]],
		["La Rosa", [BLUE, PINK]],
		["La Calavera", [SALMON, LIGHT_YELLOW]],
		["La Campana", [BLUE, BROWN]],
		["El Cantarito", [LIGHT_YELLOW, BROWN]],
		["El Venado", [BLUE, DARK_BROWN]],
		["El Sol", [BLUE, RED]],
		["La Corona", [YELLOW, BLUE]],
		["La Chalupa", [BLUE, GREEN]],
		["El Pino", [SALMON, GREEN]],
		["El Pescado", [MAGENTA, BLUE]],
		["La Palma", [SALMON, GREEN]],
		["La Maceta", [BROWN, BLUE]],
		["El Arpa", [BLUE, YELLOW]],
		["La Rana", [BLUE, GREEN]]
	];

	const u = Math.random;

	// Determine if touch is available, and if so, use that instead of click events
	const activator = window.ontouchstart ? "touchstart" : "click";

	// Audio cue to ensure that user knows that the main action button was successfully clicked
	const clickAudio = new Audio('multi-pop-2-188167.mp3');

	// Audio cue for declaring buenas!
	const buenasAudio = new Audio('success-1-6297.mp3');

	// Audio cue for fliping the card
	const flipAudio = new Audio('flipcard-91468.mp3');
	flipAudio.volume = 0.18;

	// Tactile cue for flipping the card
	const flipPulse = () => window.navigator.vibrate([50]);

	// The amount of time to show each card
	let dispTime = 4000;

	// The number of previous cards to show on the side
	let historySize = 5;

	// The amount of time to linger on the ¡BUENAS! screen
	const buenasTime = 3000;

	// Index of the current card to show on the big carta container
	let gameIndex = 0;

	const NAME = 0;
	const X_Y = 1;
	const COLOR = 2;

	// DOM element that displays the current loteria card, and is multi-use depending on the game state.
	const carta = document.getElementById("carta");
	const cartaColor = () => {
		const colors = ['white'];
		carta.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
	};
	cartaColor();

	// DOM element that displays text to the user about the current game state
	const stateText = document.getElementById("state_text");

	// DOM element that holds the previously shown cards
	const cartaHistory = document.getElementById("history");

	// DOM element that holds the current card count
	const cardCount = document.getElementById("card_count");

	// DOM element that declares the end of the game
	const buenas = document.getElementById("buenas");

	// DOM element that shows the next card when the option is available
	const next = document.getElementById("siguiente");

	// DOM element that holds the hamburger button for the menu
	const menu = document.getElementById("menu_btn");

	// DOM element that holds the menu ribbon
	const menuRibbon = document.getElementById("menu_ribbon");

	// DOM element that holds the menu options
	const menuContainer = document.getElementById("menu_container");

	// Generator function for a menu option
	function menuOption(contentArray, mClass = "menu_option") {
		const li = document.createElement("li");
		li.classList.add(mClass);

		contentArray.forEach(e => li.appendChild(e));
		return li;
	}

	// DOM element that holds the menu overlay to disengage all other page elements
	const menuOverlay = document.getElementById("menu_overlay");

	// DOM element that holds the main background
	const bg = document.getElementById("background");

	// Set the initial state of the menu and background upon load
	menu.classList.add("inactive");
	bg.classList.add("inactive");

	const ui = [
		document.getElementById("victory_background"),
		carta,
		cartaHistory
	];

	// DOM element that shows the time remaining on the current baraja
	const nextTimer = document.getElementById("siguiente_timer");

	// Opacity of the tail of the timer that circles around the "Next"/"Restart" button
	const timerTailOpacity = 1;

	// Opacity of the head of the timer that circles around the "Next"/"Restart" button
	const timerHeadOpacity = 1;

	// Colors to be used by the timer
	let timerColor = ['', ''];

	// Holds the current game
	let game = false;

	const timer = (function(g) {
		// Always animate at the best time possible with requestAnimationFrame
		const ANIMATION_MS = 0;

		let lastTickTime = Date.now();

		const beat = engine(() => {
			let deg = 360; // 360 degrees in a circle

			// If the timer was reset, then this next value must be 0
			if (Number.isFinite(lastTickTime)) {
				deg *= ((Date.now() - lastTickTime) % dispTime) / dispTime;
			} else {
				deg = 0;
				lastTickTime = Date.now();
			}

			const gradient = `conic-gradient(from 0deg, rgba(${timerColor[0]}, ${timerTailOpacity}) 0deg, rgba(${timerColor[1]}, ${timerHeadOpacity}) ${deg}deg, transparent ${deg}deg, transparent 360deg)`;
			nextTimer.style.background = gradient;
		}, ANIMATION_MS).useAnimationFrames();

		return {
			reset: function() {
				lastTickTime = Infinity;
				this.step();
			},

			run: function() {
				this.reset();
				beat.run();
			},

			stop: beat.stop,

			step: beat.step
		};
	})(game);

	// Generate the initial deck that can be used by the game
	const loteria = loteriaDeck.map((card, i) => [card[0], iTo2D(i, 6, 9), card[1]]);

	// Position each history card correctly in the viewport and apply a fade from the top to the bottom
	const positionHistory = () => {
		if (historySize > 0) {
			const l = cartaHistoryDOMArr.length;

			const wH = cartaHistory.getBoundingClientRect().height;
			const cH = cartaHistoryDOMArr[0].getBoundingClientRect().height;

			cartaHistoryDOMArr.forEach((e, i) => {
				e.style.zIndex = historySize - i + 1;
				e.style.top = `${(i * (wH - cH) / (l - 1))}px`;
				e.style.opacity = (l - i) / l;
			});
		}
	};

	// Populate the history container with the appropriate number of card slots
	let cartaHistoryDOMArr;
	function populateHistory() {
		cartaHistory.innerHTML = "";

		cartaHistoryDOMArr = Array.from({length: historySize}, () => {
			const card = document.createElement("div");
			cartaHistory.appendChild(card);
			return card;
		});

		positionHistory();
	}
	populateHistory();

	function settingsStorage() {
		const BARAJA_TIME = "barajaTime";
		const HISTORY_SIZE = "historySize";
		const SOUND_EFF = "soundEffects";

		const DEFAULT_BARAJA_TIME = 4; // seconds
		const DEFAULT_HISTORY_SIZE = 5; // baraja
		const DEFAULT_SOUND_SETTING = true; // sound effects enabled

		return {
			set: function(key, item) {
				localStorage.setItem(key, JSON.stringify(item));
				return this;
			},

			get: function(key) {
				const val = localStorage.getItem(key);
				return typeof val !== 'string' ? val : JSON.parse(val);
			},

			setBarajaTime: function(time) {
				return this.set(BARAJA_TIME, time);
			},

			setHistorySize: function(size) {
				return this.set(HISTORY_SIZE, size);
			},

			setSoundEffects: function(bool) {
				return this.set(SOUND_EFF, bool);
			},

			getBarajaTime: function() {
				return this.get(BARAJA_TIME) || DEFAULT_BARAJA_TIME;
			},

			getHistorySize: function() {
				return this.get(HISTORY_SIZE) || DEFAULT_HISTORY_SIZE;
			},

			getSoundEffectSetting: function() {
				return this.get(SOUND_EFF) || DEFAULT_SOUND_SETTING;
			},

			getDefaultBarajaTime: function() {
				return DEFAULT_BARAJA_TIME;
			},

			getDefaultHistorySize: function() {
				return DEFAULT_HISTORY_SIZE;
			},

			getDefaultSoundEffectSetting: function() {
				return DEFAULT_SOUND_SETTING;
			}
		}
	}

	function iTo2D(i, m, n) {
		if (i < 0 || i >= m * n)
			throw new Error(`Index (${i}) is out of bounds for the ${m}x${n} matrix`);

		const x = i % n;
		const y = Math.floor(i / n);

		return {x, y};
	}

	function Queue(n, onPush = arr => {}) {
		const storage = [];

		this.push = function (element) {
			storage.unshift(element);

			// The Queue only stores up to n elements
			if (storage.length > n) {
				storage.pop();
			}

			// Feed the current state of the queue to the provided function
			onPush(this.toArray());

			return this;
		};

		this.empty = function () {
			while (storage.length > 0) {
				storage.pop();
			}

			return this;
		};

		this.toArray = function () {
			return storage.map(e => e);
		}
	}

	function engine(fn, time, ...args) {
		let engineID = -1;

		let usingAnimationFrames = false;
		let startTime = -1;

		// If using requestAnimationFrame, interval can be dynamically changed between frame calls
		let currentInterval = time;
		const engineLoop = () => {
			if (startTime > 0) {
				// The minimum amount of time has elapsed to call the function again
				if ((Date.now() - startTime) >= currentInterval) {
					fn(...args);
					startTime = Date.now();
				}
				
				engineID = requestAnimationFrame(engineLoop);
			}
		}

		return {
			// Simple start
			run: function() {
				if (!this.isRunning()) {
					if (!usingAnimationFrames) {
						engineID = setInterval(fn, currentInterval, ...args);
					}

					else {
						startTime = Date.now();
						engineLoop();
					}
				}
			},

			// Return to a state of 0 and not -1 to differentiate between never executed and paused
			stop: () => {
				if (!usingAnimationFrames) {
					clearInterval(engineID);
					engineID = 0;
				}

				else {
					cancelAnimationFrame(engineID);
					startTime = 0;
				}
			},

			// Is only ever positive when it has been set by the setInterval or requestAnimationFrame functions
			isRunning: () => {
				if (!usingAnimationFrames) {
					return engineID > 0;
				}

				return startTime > 0;
			},

			// Will only ever be true if the engine has executed the "run" state at least once
			isPaused: () => {
				if (!usingAnimationFrames) {
					return engineID > -1;
				}

				return startTime > -1
			},

			// Manual call to the next loop
			step: () => fn(...args),

			// Use animationframe instead of setinterval to power the engine
			useAnimationFrames: function() {
				usingAnimationFrames = true;
				return this;
			},

			// Update the interval which the engine runs
			updateInterval: function(newInterval) {
				currentInterval = newInterval;
				return this;
			}
		};
	}

	function shuffleDeck(gameDeck) {
		gameIndex = 0;
		for (let i = gameDeck.length - 1; i > 0; i--) {
			const j = Math.floor(u() * (i + 1));

			[gameDeck[i], gameDeck[j]] = [gameDeck[j], gameDeck[i]];
		}
	}

	function showNextCard(gameDeck, cardDOMElement, synthesizer, historyQueue) {
		if (gameIndex < gameDeck.length) {
			console.log(`#${gameIndex + 1}: ${gameDeck[gameIndex][NAME]}`);

			const pos = gameDeck[gameIndex][X_Y];

			// Initialize the card flip
			flipAudio.play();
			document.getElementById("spacer").classList.toggle("playing");
			cardDOMElement.classList.toggle("flipped");

			// Show the next button that should now be available
			next.classList.remove("inactive");

			// Delay a bit to let the card turning animation complete
			setTimeout(() => {
				// Change the card that's being displayed
				cardDOMElement.style.background = `url("${loteriaImg.src}")`;
				cardDOMElement.style.backgroundSize = "900%";
				cardDOMElement.style.backgroundPosition = `${12.5 * pos.x}% ${20 * pos.y}%`;

				cardCount.classList.add("counting");
				cardCount.innerText = `${gameIndex + 1} / ${loteriaDeck.length}`;

				// Pulse to the user that a new card is coming
				flipPulse();

				// Only add data to the history queue once there's at least 1 old card
				if (gameIndex > 0) {
					historyQueue.push(gameDeck[gameIndex - 1]);
				}

				// Finalize the card flip
				setTimeout(() => {
					document.getElementById("spacer").classList.toggle("playing");
					cardDOMElement.classList.toggle("flipped");

					// Start the timer once the card has finished flipping
					timer.run();
					timerColor = gameDeck[gameIndex][COLOR];

					// Announce the new card to the players
					synthesizer.stop();
					synthesizer.play(gameDeck[gameIndex][NAME]);

					gameIndex++;

					// Force the user to reset the deck or declare buenas using the normal interface if out of cards
					if (gameIndex >= gameDeck.length) {
						timer.stop();
						timer.reset();

						next.style.backgroundImage = `url(${resetImg.src})`;
					}
				}, 50);
			}, 100);
		}
	}

	function play(gameDeck, cardDOMElement, cardHistoryDOMArray, displayCardTime = 5000) {
		menu.classList.remove("inactive");
		bg.classList.remove("inactive");

		shuffleDeck(gameDeck);

		const synth = 'speechSynthesis' in window ? (() => {
			const s = new SpeechSynthesisUtterance();
			s.lang = 'es-US';

			return {
				stop: () => window.speechSynthesis.cancel(),
				play: msg => {s.text = msg; window.speechSynthesis.speak(s);}
			};
		})() : {
			stop: () => {},
			play: msg => console.log(`Speech synthesizer not supported!`)
		};

		// Initialize the queue that will keep track of previously shown cards
		const historyQueue = new Queue(cardHistoryDOMArray.length, queue => {
			for (let i = 0; i < queue.length; i++) {
				cardHistoryDOMArray[i].style.background = `url("${loteriaImg.src}")`;
				cardHistoryDOMArray[i].style.backgroundSize = "900%";
				cardHistoryDOMArray[i].style.border = "2px solid black";

				const pos = queue[i][X_Y];
				cardHistoryDOMArray[i].style.backgroundPosition = `${12.5 * pos.x}% ${20 * pos.y}%`
				cardHistoryDOMArray[i].style.display = "block";
				positionHistory();
			}
		});

		// Starting!
		synth.play('¡Corre y se va corriendo, CON!');
		const gameLoop = engine(showNextCard, displayCardTime, gameDeck, cardDOMElement, synth, historyQueue);

		// Give the starting message enough time to finish
		setTimeout(() => {
			document.getElementById("spacer").classList.toggle("playing");
			showNextCard(gameDeck, cardDOMElement, synth, historyQueue);
			gameLoop.run();
		}, 3800);

		return gameLoop;
	}

	// Make the big carta the main controller for the game
	carta.addEventListener(activator, () => {
		// Clicking on the card after declaring buenas should no longer affect the current game
		if (!carta.classList.contains("buenas")) {
			// "engage" the click
			carta.classList.toggle('clicked');

			// Give the user the audio cue
			clickAudio.play();

			// The game has already started, so the carta is a play/pause button now
			if (game) {
				// Pause a running game
				if (game.isRunning()) {
					next.classList.toggle("alto");
					buenas.classList.toggle("alto");
					stateText.innerText = '¡Alto!';
					stateText.style.opacity = 1;

					timer.stop();
					game.stop();

				// Start a paused game
				} else if (game.isPaused()) {
					next.classList.toggle("alto");
					buenas.classList.toggle("alto");
					stateText.style.opacity = 0;

					if (gameIndex < loteria.length) {
						timer.run();
					}

					game.run();
				}

			// The game has not started yet, so the carta is a play button that initializes the game
			} else {
				// This is the first time that the game is executed after initial load or reset
				stateText.style.opacity = 0;
				game = play(loteria, carta, cartaHistoryDOMArr, dispTime);
			}

			// "release" the click
			setTimeout(() => carta.classList.toggle('clicked'), 100);
		}
	});

	// Everything that happens to reset a game to its initial condition
	const resetGame = () => {
		if (game) {
			game.stop();
		}

		game = false;

		document.getElementById("spacer").classList.toggle("playing");

		carta.style.background = `url("${barajaImg.src}")`;
		carta.style.backgroundPosition = "center";
		carta.style.backgroundSize = "100% 100%";
		cartaColor();

		cardCount.classList.remove("counting");
		cardCount.innerText = '';

		cartaHistoryDOMArr.forEach(e => {
			e.style.background = 'none';
			e.style.border = 'none';
		});

		stateText.innerText = `¡Ámonos!`;
		stateText.style.opacity = 1;

		next.style.backgroundImage = `url(${nextImg.src})`;
		next.classList.remove("alto");
		next.classList.add("inactive");

		ui.forEach(e => e.classList.remove("hidden"));
		ui.forEach(e => e.classList.remove("buenas"));

		menu.classList.add("inactive");
		bg.classList.add("inactive");
	};

	// Make the next button go to the next card
	next.addEventListener(activator, () => {
		// "engage" the click
		next.classList.add('clicked');

		// The next button becomes a refresh button when the game index is past its limit
		if (gameIndex >= loteria.length) {
			resetGame();
		} else {
			timer.stop();
			timer.reset();
			game.stop();
			game.step();
			game.run();
		}

		// "release" the click
		setTimeout(() => next.classList.remove('clicked'), 100);
	});

	// Make the buenas button declare a winner
	buenas.addEventListener(activator, () => {
		// "engage" the click
		buenas.classList.toggle('clicked');

		// "release" the click
		setTimeout(() => buenas.classList.toggle('clicked'), 100);

		// Stop the game if it is somehow still running
		game.stop();

		// This button should no longer be visible
		buenas.classList.remove("alto");

		// Hide the main UI and show the victory screen, and play the victory sound
		ui.forEach(e => e.classList.add("buenas"));
		buenasAudio.play();

		// Give the ui enough time to fade away before hiding it
		setTimeout(() => {
			ui.forEach(e => e.classList.add("hidden"));

			// Restore the game to its original state once enough time has passed on the buenas screen
			setTimeout(resetGame, buenasTime);
		}, 600);
	});

	// Make the menu button engage the proper overlays
	menu.addEventListener(activator, () => {
		menu.classList.toggle("change");
		menuRibbon.classList.toggle("engaged");
		menuOverlay.classList.toggle("engaged");
	});

	// Add the different menu functionalities
	const menuSettings = settingsStorage();

	const createText = function(text) {
		const p = document.createElement("p");
		p.appendChild(document.createTextNode(text));
		return p;
	};

	// Seconds per baraja
	menuContainer.appendChild(menuOption((function() {
		const input = document.createElement("input");
		input.type = "number";
		input.value = menuSettings.getBarajaTime();

		input.addEventListener("input", () => {
			menuSettings.setBarajaTime(input.value);
			dispTime = input.value * 1000;
		});

		return [createText("Segundos por Baraja:"), input];
	})()));

	// History size
	menuContainer.appendChild(menuOption((function() {
		const input = document.createElement("input");
		input.type = "number";
		input.value = menuSettings.getHistorySize();

		input.addEventListener("input", () => {
			menuSettings.setHistorySize(input.value);
			historySize = input.value;

			populateHistory();
		});

		return [createText("Tamaño de Historial:"), input];
	})()));

	// Add a keydown event to the window so that when spacebar is pressed, it's as if the activator was used
	window.addEventListener("keydown", e => {
		// Spacebar
		if (e.key === ' ') {
			// Prevent the default spacebar behavior of scrolling the page
			e.preventDefault();

			// Fire off the carta activator event
			carta.dispatchEvent(new Event(activator));
		}
	});

	// Make sure that the card history continues to be correctly positioned even on window resize
	window.addEventListener("resize", positionHistory);
}

</script>

</body>
</html>