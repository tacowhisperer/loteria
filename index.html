<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">

	<title>¡¡Lotería!!</title>

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

	<!-- Favicon -->
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
	<link rel="manifest" href="site.webmanifest">
	<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#00aba9">
	<meta name="theme-color" content="#ffffff">

	<style>
		@import url('https://fonts.googleapis.com/css2?family=Protest+Riot&display=swap');

		:root {
			--background-image-width: 1071px;
			--background-image-height: 1038px;

			/* I'm leaving these in here to remind myself to think before reinventing the wheel */
			--background-scroll-x: 200vw;
			--background-scroll-y: 200vh;
		}

		* {
			box-sizing: border-box;
		}

		html, body {
			margin: 0;
			padding: 0;

			/* No text elements should be selectable */
			user-select: none;

			/* Chrome makes taps look ugly on buttons that already have visual and haptic feedback */
			-webkit-tap-highlight-color: transparent;
		}

		body {
			/*background-color: black;

			height: 100vh;
			width: 100vw;

			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: center;
			align-items: center;

			overflow: hidden;*/

			background-color: black;
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			overflow: hidden;
		}

		@keyframes diagonalAnimation {
			0% {
				background-position: 0 0;
			}

			100% {
				background-position: var(--background-image-width) var(--background-image-height);
			}
		}

		#background {
			position: absolute;
			opacity: 0.65;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			transition: opacity 0.1s ease;

			background-image: url("real_esrgan_loteria.jpg");
			background-size: var(--background-image-width);
			animation: diagonalAnimation 60s linear infinite;

			z-index: -1000;
		}

		#background.buenas {
			opacity: 0;
		}

		#victory_background {
			position: absolute;
			opacity: 0;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			transition: opacity 0.60s ease;

			background-image: url("money-tree.jpg");
			background-size: cover;
			background-position: 50% 50%;
			z-index: -999;

			display: flex;
			justify-content: center;
			align-items: center;
		}

		#victory_background.buenas {
			opacity: 1;
		}

		#victory_background > p {
			font-family: 'Protest Riot', sans-serif;
			font-size: 14.5vw;
			color: #f0f0f0;
			text-shadow: 0 0 2.5vh #ccb000;
			letter-spacing: -0.35rem;
			height: 100vh;
			line-height: 100vh;
			transform: rotate(-12deg);

			position: relative;
		}

		#victory_background > p::before {
			content: "";
			position: absolute;
			width: 100%;
			height: 100%;
			top: -2%;
			left: 0%;
			z-index: -1;

			background-image: url("gold-paint.png");
			background-size: contain;
			background-repeat: no-repeat;
			background-position: center;
			transform: rotate(20deg);
		}

		#carta {
			background: url("back.png");
			background-position: center;
			background-size: 100% 100%;

			border: 1.5vh solid black;
			border-radius: 2vh;
			opacity: 1;
			height: 58.42vh; /* includes 2*border width due to box-sizing CSS */
			width: 40.06vh; /* includes 2*border width due to box-sizing CSS */

			cursor: pointer;
			transition: transform 0.025s ease, opacity 0.60s ease;
			-webkit-tap-highlight-color: transparent;

			display: flex;
			align-items: center;
			justify-content: center;

			z-index: 0;
		}

		#carta.flipped {
			transform: scaleX(0);
			transition: transform 0.1s ease;
		}

		#state_text {
			font-family: 'Protest Riot', sans-serif;
			font-size: 10vh;
			color: #f0f0f0;
			opacity: 1;
			text-shadow: 0.6vh 0.6vh 0 #333, 0.6vh -0.6vh 0 #333, -0.6vh 0.6vh 0 #333, -0.6vh -0.6vh 0 #333, 0.8485vh 0 0 #333, -0.8485vh 0 0 #333, 0 0.8485vh 0 #333, 0 -0.8485vh 0 #333, 0.7839vh 0.3247vh 0 #333, -0.7839vh 0.3247vh 0 #333, 0.7839vh -0.3247vh 0 #333, -0.7839vh -0.3247vh 0 #333, 0.3247vh 0.7839vh 0 #333, -0.3247vh 0.7839vh 0 #333, 0.3247vh -0.7839vh 0 #333, -0.3247vh -0.7839vh 0 #333;
			transform: rotate(-12deg);
			transition: opacity 0.1s ease, translate 0.1s ease;
		}

		#carta.clicked {
			scale: 1.05;
		}

		#carta.buenas {
			cursor: default;
			opacity: 0;
		}

		#history {
			height: 70vh;
			width: 8.72vh;
			opacity: 1;

			position: absolute;
			right: 1.5vw;

			transition: opacity 0.60s ease;
		}

		#history.buenas {
			opacity: 0;
		}

		#history > div {
			box-sizing: content-box;

			border: 2px solid black;
			border-radius: 5px;
			height: 13.04vh;
			width: 8.72vh;

			position: absolute;
			display: none;
		}

		#card_count {
			background-color: rgba(0, 0, 0, 0.5);
			color: white;
			border: none;
			border-radius: 1vh;

			font-family: 'Protest Riot', sans-serif;
			font-size: 2vh;
			text-align: center;
			position: absolute;

			transform: translate(14vh, -26vh);
		}

		#card_count.counting {
			padding: 0.2vh 1vh;
		}

		.nav_button {
			background-size: contain;
			background-position: center;
			cursor: pointer;
			overflow: hidden;
			height: 10vh;
			width: 10vh;
			position: fixed;
			transition: transform 0.1s ease, opacity 0.2s ease;
			z-index: 1;
		}

		#buenas {
			background-image: url("coins-29899.svg");
			transform: translate(-6.5vw, 55vh);
		}

		#buenas.clicked {
			transform: translate(-6.5vw, 37.5vh) scale(1.1);
		}

		#buenas.alto {
			transform: translate(-6.5vw, 37vh);
		}

		#siguiente {
			border-radius: 50%;
			background-image: url("next-svgrepo-com.svg");
			transform: translate(-6.5vw, 37vh);
			opacity: 1;
		}

		#siguiente.clicked {
			transform: translate(-6.5vw, 37.5vh) scale(1.1);
		}

		#siguiente.inactive {
			display: none;
			opacity: 0;
		}

		#siguiente.alto {
			transform: translate(-6.5vw, 55vh);
		}

		#siguiente_timer {
			position: absolute;
			height: 100%;
			width: 100%;

			mask-image: radial-gradient(circle at center, transparent 48%, black 50%);
		}

		.hidden {
			display: none;
		}

		#spacer {
			width: 0;
			transition: width 0.25s ease;
		}

		#spacer.playing {
			width: 13vw;
		}

		#container {
			height: 100vh;
			width: 100vw;

			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: center;
			align-items: center;

			overflow: hidden;
		}

		#loading {
			border: 1vh solid white;
			border-top: 1vh solid #333;
			border-radius: 50%;
			height: 10vh;
			width: 10vh;
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		.removed {
			display: none !important;
		}
	</style>
</head>
<body>

<div id="container">
	<div id="carta" class="removed">
		<p id="state_text">¡Ámonos!</p>
		<p id="card_count"></p>
	</div>

	<!-- Spacing for the history div -->
	<div id="spacer" class="removed"></div>

	<div id="history" class="removed">
	</div>

	<div id="siguiente" class="removed nav_button inactive">
		<div id="siguiente_timer"></div>
	</div>

	<div id="buenas" class="removed nav_button"></div>

	<div id="background" class="removed"></div>

	<div id="victory_background" class="removed">
		<p>✨¡BUENAS!✨</p>
	</div>

	<div id="loading"></div>
</div>

<script>
const container = document.getElementById("container");

const loteriaImg = new Image();
loteriaImg.src = 'loteria.jpg';

const barajaImg = new Image();
barajaImg.src = 'back.png';

const backgroundImg = new Image();
backgroundImg.src = 'real_esrgan_loteria.jpg';

const buenasImg = new Image();
buenasImg.src = 'money-tree.jpg';

const images = [loteriaImg, barajaImg, backgroundImg, buenasImg];

const loadLoop = setInterval(() => {
	const imagesLoaded = images.reduce((bool, img) => img.complete && bool, true);

	if (imagesLoaded) {
		clearInterval(loadLoop);

		// Unhide any manually removed elements that may have used required images above as backgrounds and hide the loading spinner
		[...container.children].map(e => e.classList.toggle("removed"));

		loadApp();
	}
}, 25);

function loadApp() {
	const loteriaDeck = [
		"El Gallo", "El Diablito", "La Dama", "El Catrín", "El Paraguas", "La Sirena", "La Escalera", "La Botella",
		"El Barril", "El Árbol", "El Melón", "El Valiente", "El Gorrito", "La Muerte", "La Pera", "La Bandera",
		"El Bandolón", "El Violoncello", "La Garza", "El Pájaro", "La Mano", "La Bota", "La Luna", "El Cotorro",
		"El Borracho", "El Negrito", "El Corazón", "La Sandía", "El Tambor", "El Camarón", "Las Jaras", "El Músico",
		"La Araña", "El Soldado", "La Estrella", "El Cazo", "El Mundo", "El Apache", "El Nopal", "El Alacrán",
		"La Rosa", "La Calavera", "La Campana", "El Cantarito", "El Venado", "El Sol", "La Corona", "La Chalupa",
		"El Pino", "El Pescado", "La Palma", "La Maceta", "El Arpa", "La Rana"
	];

	const u = Math.random;

	// Determine if touch is available, and if so, use that instead of click events
	const activator = window.ontouchstart ? "touchstart" : "click";

	// Audio cue to ensure that user knows that the main action button was successfully clicked
	const clickAudio = new Audio('multi-pop-2-188167.mp3');

	// Audio cue for declaring buenas!
	const buenasAudio = new Audio('success-1-6297.mp3');

	// Audio cue for fliping the card
	const flipAudio = new Audio('flipcard-91468.mp3');
	flipAudio.volume = 0.35;

	// Tactile cue for flipping the card
	const flipPulse = () => window.navigator.vibrate([100]);

	// The amount of time to show each card
	const dispTime = 4000;

	// The number of previous cards to show on the side
	const historySize = 5;

	// The amount of time to linger on the ¡BUENAS! screen
	const buenasTime = 3000;

	// Index of the current card to show on the big carta container
	let gameIndex = 0;

	const NAME = 0;
	const X_Y = 1;

	// DOM element that displays the current loteria card, and is multi-use depending on the game state.
	const carta = document.getElementById("carta");
	const cartaColor = () => {
		const colors = ['white'];
		carta.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
	};
	cartaColor();

	// DOM element that displays text to the user about the current game state
	const stateText = document.getElementById("state_text");

	// DOM element that holds the previously shown cards
	const cartaHistory = document.getElementById("history");

	// DOM element that holds the current card count
	const cardCount = document.getElementById("card_count");

	// DOM element that declares the end of the game
	const buenas = document.getElementById("buenas");

	// DOM element that shows the next card when the option is available
	const next = document.getElementById("siguiente");

	// DOM element that shows the time remaining on the current baraja
	const nextTimer = document.getElementById("siguiente_timer");

	// Engine that controls the timer animation
	const fps = 18;
	let lastTickTime = Date.now();
	const timerColor = 'rgba(220, 180, 10, 0.95)';
	const timer = engine(() => {
		const deg = ((Date.now() - lastTickTime) % dispTime) / dispTime * 360; // 360 degrees in a circle
		const gradient = `conic-gradient(from 0deg, ${timerColor} 0deg, ${timerColor} ${deg}deg, transparent ${deg}deg, transparent 360deg)`;

		nextTimer.style.background = gradient;
	}, 1000 / fps).useAnimationFrames();

	// Generate the initial deck that can be used by the game
	const loteria = loteriaDeck.map((card, i) => [card, iTo2D(i, 6, 9)]);

	// Holds the current game
	let game = false;

	// Populate the history container with the appropriate number of card slots
	const cartaHistoryDOMArr = Array.from({length: historySize}, () => {
		const card = document.createElement("div");
		cartaHistory.appendChild(card);
		return card;
	});

	// Position each history card correctly in the viewport and apply a fade from the top to the bottom
	const positionHistory = () => {
		if (historySize > 0) {
			const l = cartaHistoryDOMArr.length;

			const wH = cartaHistory.getBoundingClientRect().height;
			const cH = cartaHistoryDOMArr[0].getBoundingClientRect().height;

			cartaHistoryDOMArr.forEach((e, i) => {
				e.style.zIndex = historySize - i + 1;
				e.style.top = `${(i * (wH - cH) / (l - 1))}px`;
				e.style.opacity = (l - i) / l;
			});
		}
	};

	function iTo2D(i, m, n) {
		if (i < 0 || i >= m * n)
			throw new Error(`Index (${i}) is out of bounds for the ${m}x${n} matrix`);

		const x = i % n;
		const y = Math.floor(i / n);

		return {x, y};
	}

	function Queue(n, onPush = arr => {}) {
		const storage = [];

		this.push = function (element) {
			storage.unshift(element);

			// The Queue only stores up to n elements
			if (storage.length > n) {
				storage.pop();
			}

			// Feed the current state of the queue to the provided function
			onPush(this.toArray());

			return this;
		};

		this.empty = function () {
			while (storage.length > 0) {
				storage.pop();
			}

			return this;
		};

		this.toArray = function () {
			return storage.map(e => e);
		}
	}

	function engine(fn, time, ...args) {
		let engineID = -1;

		let usingAnimationFrames = false;
		let startTime = -1;

		return {
			// Simple start
			run: () => {
				if (!usingAnimationFrames) {
					engineID = setInterval(fn, time, ...args)
				}

				else {
					startTime = Date.now();

					let engineLoop;
					engineLoop = () => {
						if (startTime > 0) {
							// The minimum amount of time has elapsed to call the function again
							if ((Date.now() - startTime) >= time) {
								fn(...args);
								startTime = Date.now();
							}
							
							engineID = requestAnimationFrame(engineLoop);
						}
					}

					engineLoop();
				}
			},

			// Return to a state of 0 and not -1 to differentiate between never executed and paused
			stop: () => {
				if (!usingAnimationFrames) {
					clearInterval(engineID);
					engineID = 0;
				}

				else {
					cancelAnimationFrame(engineID);
					startTime = 0;
				}
			},

			// Is only ever positive when it has been set by the setInterval or requestAnimationFrame functions
			isRunning: () => {
				if (!usingAnimationFrames) {
					return engineID > 0;
				}

				return startTime > 0;
			},

			// Will only ever be true if the engine has executed the "run" state at least once
			isPaused: () => {
				if (!usingAnimationFrames) {
					return engineID > -1;
				}

				return startTime > -1
			},

			// Manual call to the next loop
			step: () => fn(...args),

			// Use animationframe instead of setinterval to power the engine
			useAnimationFrames: function() {
				useAnimationFrames = true;
				return this;
			}
		};
	}

	function shuffleDeck(gameDeck) {
		gameIndex = 0;
		for (let i = gameDeck.length - 1; i > 0; i--) {
			const j = Math.floor(u() * (i + 1));

			[gameDeck[i], gameDeck[j]] = [gameDeck[j], gameDeck[i]];
		}
	}

	function showNextCard(gameDeck, cardDOMElement, synthesizer, historyQueue) {
		console.log(`#${gameIndex + 1}: ${gameDeck[gameIndex][NAME]}`);

		const pos = gameDeck[gameIndex][X_Y];

		// Initialize the card flip
		flipAudio.play();
		document.getElementById("spacer").classList.toggle("playing");
		cardDOMElement.classList.toggle("flipped");

		// Show the next button that should now be available
		next.classList.remove("inactive");

		// Delay a bit to let the card turning animation complete
		setTimeout(() => {
			// Change the card that's being displayed
			cardDOMElement.style.background = `url("${loteriaImg.src}")`;
			cardDOMElement.style.backgroundSize = "900%";
			cardDOMElement.style.backgroundPosition = `${12.5 * pos.x}% ${20 * pos.y}%`;

			cardCount.classList.add("counting");
			cardCount.innerText = `${gameIndex + 1} / ${loteriaDeck.length}`;

			// Pulse to the user that a new card is coming
			flipPulse();

			// Only add data to the history queue once there's at least 1 old card
			if (gameIndex > 0) {
				historyQueue.push(gameDeck[gameIndex - 1]);
			}

			// Finalize the card flip
			setTimeout(() => {
				document.getElementById("spacer").classList.toggle("playing");
				cardDOMElement.classList.toggle("flipped");

				// Announce the new card to the players
				synthesizer.stop();
				synthesizer.play(gameDeck[gameIndex][NAME]);

				if (gameIndex + 1 < gameDeck.length) {
					gameIndex++;
				}

				// TODO: Eliminate this and replace it with an option to continue looping or end the game
				else {
					gameIndex = 0;
					shuffleDeck(gameDeck);
				}
			}, 50);
		}, 100);
	}

	function play(gameDeck, cardDOMElement, cardHistoryDOMArray, displayCardTime = 5000) {
		shuffleDeck(gameDeck);

		const synth = 'speechSynthesis' in window ? (() => {
			const s = new SpeechSynthesisUtterance();
			s.lang = 'es-US';

			return {
				stop: () => window.speechSynthesis.cancel(),
				play: msg => {s.text = msg; window.speechSynthesis.speak(s);}
			};
		})() : {
			play: msg => console.log(`Speech synthesizer not supported!`)
		};

		// Initialize the queue that will keep track of previously shown cards
		const historyQueue = new Queue(cardHistoryDOMArray.length, queue => {
			for (let i = 0; i < queue.length; i++) {
				cardHistoryDOMArray[i].style.background = `url("${loteriaImg.src}")`;
				cardHistoryDOMArray[i].style.backgroundSize = "900%";
				cardHistoryDOMArray[i].style.border = "2px solid black";

				const pos = queue[i][X_Y];
				cardHistoryDOMArray[i].style.backgroundPosition = `${12.5 * pos.x}% ${20 * pos.y}%`
				cardHistoryDOMArray[i].style.display = "block";
				positionHistory();
			}
		});

		// Starting!
		synth.play('¡Corre y se va corriendo, CON!');
		const gameLoop = engine(showNextCard, displayCardTime, gameDeck, cardDOMElement, synth, historyQueue);

		// Give the starting message enough time to finish
		setTimeout(() => {
			document.getElementById("spacer").classList.toggle("playing");
			showNextCard(gameDeck, cardDOMElement, synth, historyQueue);
			lastTickTime = Date.now();
			timer.run();
			gameLoop.run();
		}, 4000);

		return gameLoop;
	}

	positionHistory();

	// Make the big carta the main controller for the game
	carta.addEventListener(activator, () => {
		// Clicking on the card after declaring buenas should no longer affect the current game
		if (!carta.classList.contains("buenas")) {
			// "engage" the click
			carta.classList.toggle('clicked');

			// Give the user the audio cue
			clickAudio.play();

			// The game has already started, so the carta is a play/pause button now
			if (game) {
				// Pause a running game
				if (game.isRunning()) {
					next.classList.toggle("alto");
					buenas.classList.toggle("alto");
					stateText.innerText = '¡Alto!';
					stateText.style.opacity = 1;

					timer.stop();
					game.stop();

				// Start a paused game
				} else if (game.isPaused()) {
					next.classList.toggle("alto");
					buenas.classList.toggle("alto");
					stateText.style.opacity = 0;

					lastTickTime = Date.now();
					timer.run();
					game.run();
				}

			// The game has not started yet, so the carta is a play button that initializes the game
			} else {
				// This is the first time that the game is executed after initial load or reset
				stateText.style.opacity = 0;
				game = play(loteria, carta, cartaHistoryDOMArr, dispTime);
			}

			// "release" the click
			setTimeout(() => carta.classList.toggle('clicked'), 100);
		}
	});

	// Make the next button go to the next card
	next.addEventListener(activator, () => {
		// "engage" the click
		next.classList.toggle('clicked');

		lastTickTime = Date.now();
		game.stop();
		game.step();
		game.run();

		// "release" the click
		setTimeout(() => next.classList.toggle('clicked'), 100);
	});

	// Make the buenas button declare a winner
	buenas.addEventListener(activator, () => {
		// "engage" the click
		buenas.classList.toggle('clicked');

		// "release" the click
		setTimeout(() => buenas.classList.toggle('clicked'), 100);

		// Stop the game if it is somehow still running
		game.stop();

		// This button should no longer be visible
		buenas.classList.remove("alto");

		// Hide the main UI and show the victory screen, and play the victory sound
		const ui = [
			document.getElementById("victory_background"),
			carta,
			cartaHistory
		];
		ui.forEach(e => e.classList.toggle("buenas"));
		buenasAudio.play();

		setTimeout(() => {
			ui.forEach(e => e.classList.toggle("hidden"));

			// Restore the game to its original state once enough time has passed on the buenas screen
			setTimeout(() => {
				game = false;

				document.getElementById("spacer").classList.toggle("playing");

				carta.style.background = `url("${barajaImg.src}")`;
				carta.style.backgroundPosition = "center";
				carta.style.backgroundSize = "100% 100%";
				cartaColor();

				cardCount.classList.remove("counting");
				cardCount.innerText = '';

				cartaHistoryDOMArr.forEach(e => {
					e.style.background = 'none';
					e.style.border = 'none';
				});

				stateText.innerText = `¡Ámonos!`;

				next.classList.remove("alto");
				next.classList.add("inactive");

				ui.forEach(e => e.classList.toggle("hidden"));
				ui.forEach(e => e.classList.toggle("buenas"));
			}, buenasTime);
		}, 600);
	});

	// Add a keydown event to the window so that when spacebar is pressed, it's as if the activator was used
	window.addEventListener("keydown", e => {
		// Spacebar
		if (e.key === ' ') {
			// Prevent the default spacebar behavior of scrolling the page
			e.preventDefault();

			// Fire off the carta activator event
			carta.dispatchEvent(new Event(activator));
		}
	});

	// Make sure that the card history continues to be correctly positioned even on window resize
	window.addEventListener("resize", positionHistory);
}

</script>

</body>
</html>