<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">

	<title>¡¡Lotería!!</title>

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

	<!-- Favicon -->
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
	<link rel="manifest" href="site.webmanifest">
	<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#00aba9">
	<meta name="theme-color" content="#ffffff">

	<style>
		@import url('https://fonts.googleapis.com/css2?family=Protest+Riot&display=swap');

		:root {
			--background-image-width: 900px;
			--background-image-height: 872px;

			/* I'm leaving these in here to remind myself to think before reinventing the wheel */
			--background-scroll-x: 200vw;
			--background-scroll-y: 200vh;
		}

		* {
			box-sizing: border-box;
		}

		html, body {
			margin: 0;
			padding: 0;

			/* No text elements should be selectable */
			user-select: none;

			/* Chrome makes taps look ugly on buttons that already have visual and haptic feedback */
			-webkit-tap-highlight-color: transparent;
		}

		body {
			background-color: black;
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			overflow: hidden;
		}

		@keyframes diagonalAnimation {
			0% { background-position: 0 0; }
			100% { background-position: var(--background-image-width) var(--background-image-height); }
		}

		#background {
			position: absolute;
			opacity: 0.3;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			transition: opacity 0.2s ease;

			background-image: url("real_esrgan_loteria.jpg");
			background-size: var(--background-image-width);
			animation: diagonalAnimation 360s linear infinite;

			z-index: -1000;
		}

		#background.inactive {
			opacity: 0.5;
		}

		#background.buenas {
			opacity: 0;
		}

		#victory_background {
			position: absolute;
			opacity: 0;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			transition: opacity 0.60s ease;

			background-image: url("money-tree.jpg");
			background-size: cover;
			background-position: 50% 50%;
			z-index: -999;

			display: flex;
			justify-content: center;
			align-items: center;
		}

		#victory_background.buenas {
			opacity: 1;
		}

		#victory_background > p {
			font-family: 'Protest Riot', sans-serif;
			font-size: 14.5vw;
			color: #f0f0f0;
			text-shadow: 0 0 2.5vh #ccb000;
			letter-spacing: -0.35rem;
			height: 100vh;
			line-height: 100vh;
			transform: rotate(-12deg);

			position: relative;
		}

		#victory_background > p::before {
			content: "";
			position: absolute;
			width: 100%;
			height: 100%;
			top: -2%;
			left: 0%;
			z-index: -1;

			background-image: url("gold-paint.png");
			background-size: contain;
			background-repeat: no-repeat;
			background-position: center;
			transform: rotate(20deg);
		}

		#carta {
			background: url("back.png");
			background-position: center;
			background-size: 100% 100%;

			border: 1.5vh solid black;
			border-radius: 2vh;
			opacity: 1;
			height: 58.42vh; /* includes 2*border width due to box-sizing CSS */
			width: 40.06vh; /* includes 2*border width due to box-sizing CSS */

			cursor: pointer;
			transition: transform 0.025s ease, opacity 0.60s ease;
			-webkit-tap-highlight-color: transparent;

			display: flex;
			align-items: center;
			justify-content: center;

			z-index: 0;
		}

		#carta.flipped {
			transform: scaleX(0);
			transition: transform 0.1s ease;
		}

		#state_text {
			font-family: 'Protest Riot', sans-serif;
			font-size: 10vh;
			color: #f0f0f0;
			opacity: 1;
			text-shadow: 0.6vh 0.6vh 0 #333, 0.6vh -0.6vh 0 #333, -0.6vh 0.6vh 0 #333, -0.6vh -0.6vh 0 #333, 0.8485vh 0 0 #333, -0.8485vh 0 0 #333, 0 0.8485vh 0 #333, 0 -0.8485vh 0 #333, 0.7839vh 0.3247vh 0 #333, -0.7839vh 0.3247vh 0 #333, 0.7839vh -0.3247vh 0 #333, -0.7839vh -0.3247vh 0 #333, 0.3247vh 0.7839vh 0 #333, -0.3247vh 0.7839vh 0 #333, 0.3247vh -0.7839vh 0 #333, -0.3247vh -0.7839vh 0 #333;
			transform: rotate(-12deg);
			transition: 0.1s ease;
		}

		#state_text.explode {
			transform: scale(2);
		}

		#carta.clicked {
			scale: 1.05;
		}

		#carta.buenas {
			cursor: default;
			opacity: 0;
		}

		#history {
			height: 70vh;
			width: 8.72vh;
			opacity: 1;

			position: absolute;
			right: 1.5vw;

			transition: opacity 0.60s ease;
		}

		#history.buenas {
			opacity: 0;
		}

		#history > div {
			box-sizing: content-box;

			border: 2px solid black;
			border-radius: 5px;
			height: 13.04vh;
			width: 8.72vh;

			position: absolute;
			display: none;
		}

		#card_count {
			background-color: rgba(0, 0, 0, 0.5);
			color: white;
			border: none;
			border-radius: 1vh;

			font-family: 'Protest Riot', sans-serif;
			font-size: 2vh;
			text-align: center;
			position: absolute;

			transform: translate(14vh, -26vh);
		}

		#card_count.counting {
			padding: 0.2vh 1vh;
		}

		.nav_button {
			background-size: contain;
			background-position: center;
			cursor: pointer;
			overflow: hidden;
			height: 10vh;
			width: 10vh;
			position: fixed;
			transition: transform 0.1s ease, opacity 0.2s ease;
			z-index: 1;
		}

		#buenas {
			background-image: url("coins-29899.svg");
			transform: translate(-6.5vw, 55vh);
		}

		#buenas.clicked {
			transform: translate(-6.5vw, 37.5vh) scale(1.1);
		}

		#buenas.alto {
			transform: translate(-6.5vw, 37vh);
		}

		#siguiente {
			border-radius: 50%;
			background-image: url("next-svgrepo-com.svg");
			transform: translate(-6.5vw, 37vh);
			opacity: 1;
		}

		#siguiente.clicked {
			transform: translate(-6.5vw, 37.5vh) scale(1.1);
		}

		#siguiente.inactive {
			display: none;
			opacity: 0;
		}

		#siguiente.alto {
			transform: translate(-6.5vw, 55vh);
		}

		#siguiente_timer {
			position: absolute;
			height: 100%;
			width: 100%;

			mask-image: radial-gradient(circle at center, transparent 48%, black 50%);
		}

		.hidden {
			display: none;
		}

		#spacer {
			width: 0;
			transition: width 0.25s ease;
		}

		#spacer.playing {
			width: 13vw;
		}

		#container {
			height: 100vh;
			width: 100vw;

			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: center;
			align-items: center;

			overflow: hidden;
		}

		#loading {
			border: 1vh solid white;
			border-top: 1vh solid #333;
			border-radius: 50%;
			height: 10vh;
			width: 10vh;
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

		.removed {
			display: none !important;
		}

		#menu_btn_container {
			position: fixed;

			padding: 1.5rem;

			top: 0;
			left: 0;
			z-index: 3;
		}

		#menu_btn.inactive {
			display: flex;
		}

		#menu_btn {
			display: none;
			flex-direction: column;
			cursor: pointer;
		}

		.hamburger_bar {
			background-color: #eee;
			border-radius: 0.5rem;
			width: 3.5rem;
			height: 0.5rem;
			margin: 0.3rem 0;
			transition: 0.1s;
		}

		.change .hamburger_bar:nth-child(1) {
			transform: translate(0, 1.07rem) rotate(-45deg);
		}

		.change .hamburger_bar:nth-child(2) {
			transform: scaleX(0);
			opacity: 0;
		}

		.change .hamburger_bar:nth-child(3) {
			transform: translate(0, -1.07rem) rotate(45deg);
		}

		#menu_ribbon {
			display: flex;
			position: fixed;
			background-color: rgba(0, 0, 0, 0.75);
			color: #eee;
			font-family: 'Protest Riot', sans-serif;
			font-size: min(5.5vw, 5.5vh);
			top: 0;
			left: 0;
			overflow-y: auto;
			padding-top: 6rem;
			height: 100vh;
			width: min(100vw, 100vh);
			transform: translate(-100%, 0);
			transition: 0.1s ease;
			z-index: 2;
		}

		#menu_ribbon > * {
			margin-left: 0.75rem;
			margin-top: 0.5rem;
			margin-bottom: 0.5rem;
		}

		#menu_ribbon.engaged {
			transform: translate(0, 0);
		}

		#menu_container {
			list-style-type: none;
			padding-left: 0;
			width: 100%;
		}

		#menu_container li:last-child {
			padding-bottom: 3vh;
		}

		.menu_option {
			display: flex;
			flex-wrap: wrap;
			justify-content: flex-start;
			column-gap: max(2vw, 2vh);
			align-items: center;
			align-content: center;
		}

		.menu_option + .menu_option {
			margin-top: 3vh;
			padding-top: 3vh;
			border-top: 0.15rem solid;
			border-image: linear-gradient(to right, #d80b77, transparent) 1 0 0 0;
		}

		#menu_overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 1;
		}

		#menu_overlay.engaged {
			display: block;
		}

		/* Chrome, Safari, Edge, Opera */
		input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		/* Firefox */
		input[type=number] {
			-moz-appearance: textfield;
		}

		input {
			aspect-ratio: 3 / 2;
			color: #eee;
			display: block;
			background-color: rgba(0, 0, 0, 1.0);
			border: none;
			border-radius: 1rem;
			font-family: 'Protest Riot', sans-serif;
			font-size: min(5vw, 5vh);
			text-align: center;
			padding: 1rem;
			height: min(15vw, 15vh);
		}

		/* Toggle CSS */
		.toggle-container {
			display: inline-block;
			position: relative;
		}

		.toggle-input {
			display: none;
		}

		.toggle-track {
			width: max(8vw, 8vh);
			height: max(4vw, 4vh);
			background-color: #ddd;
			border-radius: max(4vw, 4vh);
			top: 0;
			left: 0;
			transition: background-color 0.2s ease;
		}

		.toggle-thumb {
			width: max(4vw, 4vh);
			height: max(4vw, 4vh);
			background-color: #fff;
			border-radius: 50%;
			position: absolute;
			top: 0;
			left: 0;
			transition: transform 0.2s ease;
		}

		.toggle-input:checked + .toggle-track {
			background-color: #d80b77;
		}

		.toggle-input:checked + .toggle-track .toggle-thumb {
			transform: translateX(max(4vw, 4vh));
		}

		/* Misc */
		.panic-button {
			aspect-ratio: 3 / 2;
			background-color: #a5a5a580;
			border-radius: min(2vw, 2vh);
			display: flex;
			justify-content: center;
			align-items: center;
			white-space: nowrap;

			color: #eee;
			cursor: pointer;
			padding: max(2vw, 2vw);

			height: min(15vw, 15vh);
			transition: 0.2s ease;
		}

		.panic-button.active {
			background-color: #d80b7780;
		}
	</style>
</head>
<body>

<div id="container">
	<div id="menu_btn_container" class="removed">
		<div id="menu_btn">
			<div class="hamburger_bar"></div>
			<div class="hamburger_bar"></div>
			<div class="hamburger_bar"></div>
		</div>
	</div>

	<div id="menu_ribbon" class="removed">
		<ul id="menu_container">
			<!-- <li class="menu_option"><p>Reproducir Sonidos:</p><div style="height: 3rem; width: 3rem; background-color: blue;"></div></li> -->
		</ul>
	</div>

	<div id="menu_overlay" class="removed"></div>

	<div id="carta" class="removed">
		<p id="state_text">¡Ámonos!</p>
		<p id="card_count"></p>
	</div>

	<!-- Spacing for the history div -->
	<div id="spacer" class="removed"></div>

	<div id="history" class="removed">
	</div>

	<div id="siguiente" class="removed nav_button inactive">
		<div id="siguiente_timer"></div>
	</div>

	<div id="buenas" class="removed nav_button"></div>

	<div id="background" class="removed"></div>

	<div id="victory_background" class="removed">
		<p>✨¡BUENAS!✨</p>
	</div>

	<div id="loading"></div>
</div>

<script>
const container = document.getElementById("container");

const loteriaImg = new Image();
loteriaImg.src = 'loteria.jpg';

const barajaImg = new Image();
barajaImg.src = 'back.png';

const backgroundImg = new Image();
backgroundImg.src = 'real_esrgan_loteria.jpg';

const buenasImg = new Image();
buenasImg.src = 'money-tree.jpg';

const resetImg = new Image();
resetImg.src = 'refresh-circle-svgrepo-com.svg';

const nextImg = new Image();
nextImg.src = 'next-svgrepo-com.svg';

const images = [loteriaImg, barajaImg, backgroundImg, buenasImg, resetImg, nextImg];

const loadLoop = setInterval(() => {
	const imagesLoaded = images.reduce((bool, img) => img.complete && bool, true);

	if (imagesLoaded) {
		clearInterval(loadLoop);

		// Unhide any manually removed elements that may have used required images above as backgrounds and hide the loading spinner
		[...container.children].map(e => e.classList.toggle("removed"));

		loadApp();
	}
}, 25);

function loadApp() {
	// App settings
	const menuSettings = settingsStorage();

	// Baraja theme colors
	const YELLOW = '220, 180, 10';
	const LIGHT_YELLOW = '250, 220, 100';
	const BLUE = '10, 175, 220';
	const RED = '220, 20, 10';
	const MAGENTA = '220, 10, 220';
	const GREEN = '10, 175, 10';
	const WHITE = '250, 250, 250';
	const BLACK = '0, 0, 0';
	const PINK = '235, 60, 165';
	const SALMON = '240, 125, 190';
	const SKIN = '240, 145, 125';
	const SCARLET = '235, 5, 5';
	const BROWN = '195, 55, 5';
	const DARK_BROWN = '110, 50, 0';

	const loteriaDeck = [
		["El Gallo", [BLUE, GREEN]],
		["El Diablito", [YELLOW, RED]],
		["La Dama", [SALMON, BLUE]],
		["El Catrín", [LIGHT_YELLOW, SALMON]],
		["El Paraguas", [BLACK, BLUE]],
		["La Sirena", [BLUE, RED]],
		["La Escalera", [PINK, BLUE]],
		["La Botella", [SALMON, RED]],
		["El Barril", [YELLOW, GREEN]],
		["El Árbol", [SALMON, GREEN]],
		["El Melón", [BLUE, SKIN]],
		["El Valiente", [SALMON, BLUE]],
		["El Gorrito", [LIGHT_YELLOW, RED]],
		["La Muerte", [SALMON, YELLOW]],
		["La Pera", [BLUE, GREEN]],
		["La Bandera", [LIGHT_YELLOW, GREEN]],
		["El Bandolón", [BLUE, LIGHT_YELLOW]],
		["El Violoncello", [WHITE, YELLOW]],
		["La Garza", [BLUE, GREEN]],
		["El Pájaro", [RED, YELLOW]],
		["La Mano", [SKIN, BLUE]],
		["La Bota", [BLACK, YELLOW]],
		["La Luna", [BLUE, WHITE]],
		["El Cotorro", [SCARLET, GREEN]],
		["El Borracho", [LIGHT_YELLOW, SALMON]],
		["El Negrito", [LIGHT_YELLOW, BLUE]],
		["El Corazón", [LIGHT_YELLOW, RED]],
		["La Sandía", [PINK, GREEN]],
		["El Tambor", [BLUE, YELLOW]],
		["El Camarón", [YELLOW, RED]],
		["Las Jaras", [BLUE, YELLOW]],
		["El Músico", [YELLOW, BLUE]],
		["La Araña", [BLACK, BLUE]],
		["El Soldado", [YELLOW, SALMON]],
		["La Estrella", [WHITE, BLUE]],
		["El Cazo", [SCARLET, LIGHT_YELLOW]],
		["El Mundo", [BLUE, LIGHT_YELLOW]],
		["El Apache", [LIGHT_YELLOW, SKIN]],
		["El Nopal", [GREEN, BLUE]],
		["El Alacrán", [BLACK, LIGHT_YELLOW]],
		["La Rosa", [BLUE, PINK]],
		["La Calavera", [SALMON, LIGHT_YELLOW]],
		["La Campana", [BLUE, BROWN]],
		["El Cantarito", [LIGHT_YELLOW, BROWN]],
		["El Venado", [BLUE, DARK_BROWN]],
		["El Sol", [BLUE, RED]],
		["La Corona", [YELLOW, BLUE]],
		["La Chalupa", [BLUE, GREEN]],
		["El Pino", [SALMON, GREEN]],
		["El Pescado", [MAGENTA, BLUE]],
		["La Palma", [SALMON, GREEN]],
		["La Maceta", [BROWN, BLUE]],
		["El Arpa", [BLUE, YELLOW]],
		["La Rana", [BLUE, GREEN]]
	];

	const u = Math.random;

	function loteriaAudio(filename, volume = 1) {
		const sound = new Audio(filename);

		return {
			mute: function() {
				sound.volume = 0;

				return this;
			},

			unmute: function() {
				sound.volume = volume;

				return this;
			},

			play: () => sound.play()
		};
	}

	// Determine if touch is available, and if so, use that instead of click events
	const activator = window.ontouchstart ? "touchstart" : "click";

	// Audio cue to ensure that user knows that the main action button was successfully clicked
	const clickAudio = loteriaAudio('multi-pop-2-188167.mp3');

	// Audio cue for declaring buenas!
	const buenasAudio = loteriaAudio('success-1-6297.mp3');

	// Audio cue for fliping the card
	const flipAudio = loteriaAudio('flipcard-91468.mp3', 0.17);

	// Audio cue for shuffling the deck
	const shuffleAudio = loteriaAudio('card-shuffle-10_zkdC1fVu_NWM.mp3');

	// All special sound effects
	const audioUI = [clickAudio, buenasAudio, flipAudio, shuffleAudio];

	// The amount of time to linger on the ¡BUENAS! screen
	const buenasTime = 2700;

	// Index of the current card to show on the big carta container
	let gameIndex = 0;

	// Tactile cue for flipping the card
	let vibrate = menuSettings.getVibrationSetting();
	const flipPulse = () => vibrate ? window.navigator.vibrate([60]) : null;

	// The amount of time to show each card
	let dispTime = 1000 * menuSettings.getBarajaTimeSetting();

	// The number of previous cards to show on the side
	let historySize = menuSettings.getHistorySizeSetting();

	// Whether to fade out the history or not
	let fadeHistory = menuSettings.getFadeHistorySetting();

	// Whether or not the speech synthesizer should announce the baraja
	let announceBaraja = menuSettings.getAnnouncementSetting();

	// Whether the game should show the next card or it should be done manually
	let autoFlip = menuSettings.getAutoFlipModeSetting();

	// Speech synthesizer (if supported)
	const synth = 'speechSynthesis' in window ? (() => {
		const s = new SpeechSynthesisUtterance();
		s.lang = 'es-US';

		return {
			stop: function() {
				window.speechSynthesis.cancel();
			},

			play: function(msg) {
				if (announceBaraja) {
					s.text = msg;

					this.stop();
					window.speechSynthesis.speak(s);
				}
			}
		};
	})() : {
		stop: () => {},
		play: msg => console.log(`Speech synthesizer not supported!`)
	};

	const NAME = 0;
	const X_Y = 1;
	const COLOR = 2;

	// DOM element that displays the current loteria card, and is multi-use depending on the game state.
	const carta = document.getElementById("carta");
	const cartaColor = () => {
		const colors = ['white'];
		carta.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
	};
	cartaColor();

	// DOM element that displays text to the user about the current game state
	const stateText = document.getElementById("state_text");

	// DOM element that holds the previously shown cards
	const cartaHistory = document.getElementById("history");

	// DOM element that holds the current card count
	const cardCount = document.getElementById("card_count");

	// DOM element that declares the end of the game
	const buenas = document.getElementById("buenas");

	// DOM element that shows the next card when the option is available
	const next = document.getElementById("siguiente");

	// DOM element that holds the hamburger button for the menu
	const menu = document.getElementById("menu_btn");

	// DOM element that holds the menu ribbon
	const menuRibbon = document.getElementById("menu_ribbon");

	// DOM element that holds the menu options
	const menuContainer = document.getElementById("menu_container");

	// Generator function for a menu option
	function menuOption(contentArray, mClass = "menu_option") {
		const li = document.createElement("li");
		li.classList.add(mClass);

		contentArray.forEach(e => li.appendChild(e));
		return li;
	}

	// DOM element that holds the menu overlay to disengage all other page elements
	const menuOverlay = document.getElementById("menu_overlay");

	// DOM element that holds the main background
	const bg = document.getElementById("background");

	// Set the initial state of the menu and background upon load
	menu.classList.add("inactive");
	bg.classList.add("inactive");

	const ui = [
		document.getElementById("victory_background"),
		carta,
		cartaHistory
	];

	// DOM element that shows the time remaining on the current baraja
	const nextTimer = document.getElementById("siguiente_timer");

	// Opacity of the tail of the timer that circles around the "Next"/"Restart" button
	const timerTailOpacity = 1;

	// Opacity of the head of the timer that circles around the "Next"/"Restart" button
	const timerHeadOpacity = 1;

	// Colors to be used by the timer
	let timerColor = ['', ''];

	// Holds the current game
	let game = false;

	const timer = (function(g) {
		// Always animate at the best time possible with requestAnimationFrame
		const ANIMATION_MS = 0;

		let lastTickTime = Date.now();

		const beat = engine(() => {
			let deg = 360; // 360 degrees in a circle

			// If the timer was reset, then this next value must be 0
			if (Number.isFinite(lastTickTime)) {
				const delta = Date.now() - lastTickTime;

				// Don't continue the timer once the dispTime ms have elapsed
				if (delta <= dispTime) {
					deg *= ((Date.now() - lastTickTime) % dispTime) / dispTime;
				}
			} else {
				deg = 0;
				lastTickTime = Date.now();
			}

			const gradient = `conic-gradient(from 0deg, rgba(${timerColor[0]}, ${timerTailOpacity}) 0deg, rgba(${timerColor[1]}, ${timerHeadOpacity}) ${deg}deg, transparent ${deg}deg, transparent 360deg)`;
			nextTimer.style.background = gradient;
		}, ANIMATION_MS).useAnimationFrames();

		return {
			reset: function() {
				lastTickTime = Infinity;
				this.step();
			},

			run: function() {
				this.reset();
				beat.run();
			},

			stop: beat.stop,

			step: beat.step
		};
	})(game);

	// Generate the initial deck that can be used by the game
	const loteria = loteriaDeck.map((card, i) => [card[0], iTo2D(i, 6, 9), card[1]]);

	// Position each history card correctly in the viewport and apply a fade from the top to the bottom
	const positionHistory = () => {
		if (historySize > 0) {
			const l = cartaHistoryDOMArr.length;

			const wH = cartaHistory.getBoundingClientRect().height;
			const cH = cartaHistoryDOMArr[0].getBoundingClientRect().height;

			cartaHistoryDOMArr.forEach((e, i) => {
				e.style.zIndex = historySize - i + 1;
				e.style.top = `${(i * (wH - cH) / (l - 1))}px`;

				if (fadeHistory) {
					e.style.opacity = (l - i) / l;
				} else {
					e.style.opacity = 1;
				}
			});
		}
	};

	// Populate the history container with the appropriate number of card slots
	let cartaHistoryDOMArr;
	function populateHistory() {
		cartaHistory.innerHTML = "";

		cartaHistoryDOMArr = Array.from({length: historySize}, () => {
			const card = document.createElement("div");
			cartaHistory.appendChild(card);
			return card;
		});

		positionHistory();
	}
	populateHistory();

	function settingsStorage() {
		const settings = {
			"BarajaTime":	5.5,	// seconds per display of baraja
			"SoundEffect":	true,	// sfx sounds
			"Announcement":	true,	// synthesizer speech
			"Vibration":	true,	// device vibration on baraja flip
			"HistorySize":	5,		// cards of history remain on display
			"FadeHistory":	true,	// fade baraja out as they show
			"AutoFlipMode":	true	// auto-flip to next baraja
		};

		const get = key => {
			const val = localStorage.getItem(key);
			return typeof val !== 'string' ? val : JSON.parse(val);
		};

		const set = (key, value) => {
			localStorage.setItem(key, JSON.stringify(value));
		};

		const getterSetter = {};
		Object.keys(settings).forEach(s => {
			getterSetter[`get${s}Setting`] = () => {const v = get(s); return v === null ? settings[s] : v;};
			getterSetter[`set${s}Setting`] = value => set(s, value);
			getterSetter[`getDefault${s}Setting`] = () => settings[s];
		});
		return getterSetter;
	}

	function iTo2D(i, m, n) {
		if (i < 0 || i >= m * n)
			throw new Error(`Index (${i}) is out of bounds for the ${m}x${n} matrix`);

		const x = i % n;
		const y = Math.floor(i / n);

		return {x, y};
	}

	function Queue(n, onPush = arr => {}) {
		const storage = [];

		this.push = function (element) {
			storage.unshift(element);

			// The Queue only stores up to n elements
			if (storage.length > n) {
				storage.pop();
			}

			// Feed the current state of the queue to the provided function
			onPush(this.toArray());

			return this;
		};

		this.empty = function () {
			while (storage.length > 0) {
				storage.pop();
			}

			return this;
		};

		this.toArray = function () {
			return storage.map(e => e);
		}
	}

	function engine(fn, time, ...args) {
		let engineID = -1;

		let usingAnimationFrames = false;
		let startTime = -1;

		let autoLoop = true;

		// If using requestAnimationFrame, interval can be dynamically changed between frame calls
		let currentInterval = time;
		const setAnimationLoop = () => {
			if (startTime > 0) {
				// The minimum amount of time has elapsed to call the function again
				if ((Date.now() - startTime) >= currentInterval) {
					fn(...args);
					startTime = Date.now();
				}

				engineID = requestAnimationFrame(setAnimationLoop);
			}
		}

		return {
			// Simple start
			run: function() {
				if (!this.isRunning() && autoLoop) {
					if (!usingAnimationFrames) {
						engineID = setInterval(fn, currentInterval, ...args);
					}

					else {
						startTime = Date.now();
						setAnimationLoop();
					}
				}

				// run called on manual mode, so enable the engine but don't activate an automatic loop
				else if (!autoLoop) {
					engineID = 1;
					startTime = 1;
				}

				return this;
			},

			// Return to a state of 0 and not -1 to differentiate between never executed and paused
			stop: function() {
				if (!usingAnimationFrames) {
					clearInterval(engineID);
					engineID = 0;
				}

				else {
					cancelAnimationFrame(engineID);
					startTime = 0;
				}

				return this;
			},

			isRunning: function() {
				// Values are only ever true when they have been set by the run method
				if (!usingAnimationFrames) {
					return engineID > 0;
				}

				return startTime > 0;
			},

			// Will only ever be true if the engine has executed the "run" state at least once
			isPaused: function() {
				if (!usingAnimationFrames) {
					return engineID > -1;
				}

				return startTime > -1
			},

			// Manual call to the next loop
			step: function() {
				fn(...args);
				return this;
			},

			// Use animationframe instead of setinterval to power the engine
			useAnimationFrames: function() {
				usingAnimationFrames = true;
				return this;
			},

			// Update the interval which the engine runs
			updateInterval: function(newInterval) {
				currentInterval = newInterval;
				return this;
			},

			// Set the engine to fire only on call instead of in an interval
			manualFire: function() {
				autoLoop = false;
				return this;
			},

			// Set the engine to fire automatically
			autoFire: function() {
				autoLoop = true;
				return this;
			},

			setFire: function(automaticMode) {
				return automaticMode ? this.autoFire() : this.manualFire();
			}
		};
	}

	function shuffleDeck(gameDeck) {
		gameIndex = 0;

		// Fisher-Yates shuffle algorithm
		for (let i = gameDeck.length - 1; i > 0; i--) {
			const j = Math.floor(u() * (i + 1));

			[gameDeck[i], gameDeck[j]] = [gameDeck[j], gameDeck[i]];
		}
	}

	function showNextCard(gameDeck, cardDOMElement, historyQueue) {
		if (gameIndex < gameDeck.length) {
			console.log(`#${gameIndex + 1}: ${gameDeck[gameIndex][NAME]}`);

			const pos = gameDeck[gameIndex][X_Y];

			// Initialize the card flip
			flipAudio.play();
			document.getElementById("spacer").classList.toggle("playing");
			cardDOMElement.classList.toggle("flipped");

			// Show the next button that should now be available
			next.classList.remove("inactive");

			// Delay a bit to let the card turning animation complete
			setTimeout(() => {
				// Change the card that's being displayed
				cardDOMElement.style.background = `url("${loteriaImg.src}")`;
				cardDOMElement.style.backgroundSize = "900%";
				cardDOMElement.style.backgroundPosition = `${12.5 * pos.x}% ${20 * pos.y}%`;

				cardCount.classList.add("counting");
				cardCount.innerText = `${gameIndex + 1} / ${loteriaDeck.length}`;

				// Pulse to the user that a new card is coming
				flipPulse();

				// Only add data to the history queue once there's at least 1 old card
				if (gameIndex > 0) {
					historyQueue.push(gameDeck[gameIndex - 1]);
				}

				// Finalize the card flip
				setTimeout(() => {
					document.getElementById("spacer").classList.toggle("playing");
					cardDOMElement.classList.toggle("flipped");

					// Start the timer once the card has finished flipping
					timer.run();
					timerColor = gameDeck[gameIndex][COLOR];

					// Announce the new card to the players
					synth.play(gameDeck[gameIndex][NAME]);

					gameIndex++;

					// Force the user to reset the deck or declare buenas using the normal interface if out of cards
					if (gameIndex >= gameDeck.length) {
						timer.stop();
						timer.reset();

						next.style.backgroundImage = `url(${resetImg.src})`;
					}
				}, 50);
			}, 100);
		}
	}

	function play(gameDeck, cardDOMElement, cardHistoryDOMArray, displayCardTime = 5000) {
		stateText.innerText = "¡Corre!";
		setTimeout(() => {
			stateText.classList.add("explode");
			stateText.style.opacity = 0;
		}, 750);

		menu.classList.remove("inactive");
		bg.classList.remove("inactive");

		shuffleDeck(gameDeck);

		// Initialize the queue that will keep track of previously shown cards
		const historyQueue = new Queue(cardHistoryDOMArray.length, queue => {
			for (let i = 0; i < queue.length; i++) {
				cardHistoryDOMArray[i].style.background = `url("${loteriaImg.src}")`;
				cardHistoryDOMArray[i].style.backgroundSize = "900%";
				cardHistoryDOMArray[i].style.border = "2px solid black";

				const pos = queue[i][X_Y];
				cardHistoryDOMArray[i].style.backgroundPosition = `${12.5 * pos.x}% ${20 * pos.y}%`
				cardHistoryDOMArray[i].style.display = "block";
				positionHistory();
			}
		});

		// Starting!
		synth.play('¡Corre y se va corriendo, CON!');
		const gameLoop = engine(showNextCard, displayCardTime, gameDeck, cardDOMElement, historyQueue).setFire(autoFlip);

		// Give the starting message enough time to finish
		setTimeout(() => {
			stateText.classList.remove("explode");

			document.getElementById("spacer").classList.toggle("playing");
			showNextCard(gameDeck, cardDOMElement, historyQueue);
			gameLoop.run();
		}, 3800);

		return gameLoop;
	}

	// Make the big carta the main controller for the game
	carta.addEventListener(activator, () => {
		// Clicking on the card after declaring buenas should no longer affect the current game
		if (!carta.classList.contains("buenas")) {
			// "engage" the click
			carta.classList.toggle('clicked');

			// Give the user the audio cue
			clickAudio.play();

			// The game has already started, so the carta is a play/pause button now
			if (game) {
				// Pause a running game
				if (game.isRunning()) {
					next.classList.toggle("alto");
					buenas.classList.toggle("alto");
					stateText.innerText = '¡Alto!';
					stateText.style.opacity = 1;

					timer.stop();
					game.stop();

				// Start a paused game
				} else if (game.isPaused()) {
					next.classList.toggle("alto");
					buenas.classList.toggle("alto");
					stateText.style.opacity = 0;

					if (gameIndex < loteria.length) {
						timer.run();
					}

					game.run();
				}

			// The game has not started yet, so the carta is a play button that initializes the game
			} else {
				// This is the first time that the game is executed after initial load or reset
				game = play(loteria, carta, cartaHistoryDOMArr, dispTime);
			}

			// "release" the click
			setTimeout(() => carta.classList.toggle('clicked'), 100);
		}
	});

	// Everything that happens to reset a game to its initial condition
	const resetGame = () => {
		shuffleAudio.play();

		// Give the shuffle deck sound some time to play before loading the initial screen again
		setTimeout(() => {
			if (game) {
				game.stop();
			}

			game = false;

			document.getElementById("spacer").classList.toggle("playing");

			carta.style.background = `url("${barajaImg.src}")`;
			carta.style.backgroundPosition = "center";
			carta.style.backgroundSize = "100% 100%";
			cartaColor();

			cardCount.classList.remove("counting");
			cardCount.innerText = '';

			cartaHistoryDOMArr.forEach(e => {
				e.style.background = 'none';
				e.style.border = 'none';
			});

			stateText.innerText = `¡Ámonos!`;
			stateText.style.opacity = 1;

			next.style.backgroundImage = `url(${nextImg.src})`;
			next.classList.remove("alto");
			next.classList.add("inactive");

			ui.forEach(e => e.classList.remove("hidden"));
			ui.forEach(e => e.classList.remove("buenas"));

			menu.classList.add("inactive");
			bg.classList.add("inactive");
		}, 400);
	};

	// Make the next button go to the next card
	next.addEventListener(activator, () => {
		// "engage" the click
		next.classList.add('clicked');

		// The next button becomes a refresh button when the game index is past its limit
		if (gameIndex >= loteria.length) {
			resetGame();
		} else {
			timer.stop();
			timer.reset();
			game.stop();
			game.step();
			game.run();
		}

		// "release" the click
		setTimeout(() => next.classList.remove('clicked'), 100);
	});

	// Make the buenas button declare a winner
	buenas.addEventListener(activator, () => {
		// "engage" the click
		buenas.classList.toggle('clicked');

		// "release" the click
		setTimeout(() => buenas.classList.toggle('clicked'), 100);

		// Stop the game if it is somehow still running
		game.stop();

		// This button should no longer be visible
		buenas.classList.remove("alto");

		// Hide the main UI and show the victory screen, and play the victory sound
		ui.forEach(e => e.classList.add("buenas"));
		buenasAudio.play();

		// Give the ui enough time to fade away before hiding it
		setTimeout(() => {
			ui.forEach(e => e.classList.add("hidden"));

			// Restore the game to its original state once enough time has passed on the buenas screen
			setTimeout(resetGame, buenasTime);
		}, 600);
	});

	// Make the menu button engage the proper overlays
	menu.addEventListener(activator, () => {
		menu.classList.toggle("change");
		menuRibbon.classList.toggle("engaged");
		menuOverlay.classList.toggle("engaged");
	});

	// Make the overlay disengage the menu if it's accessible
	menuOverlay.addEventListener(activator, () => {
		menu.classList.remove("change");
		menuRibbon.classList.remove("engaged");
		menuOverlay.classList.remove("engaged");
	});

	// Access array for the menu reset button
	const resetters = [];

	const createText = function(text) {
		const p = document.createElement("p");
		p.appendChild(document.createTextNode(text));
		return p;
	};

	const createToggleSwitch = function() {
		// Creation of the toggle slider
		const input = document.createElement("input");
		input.type = "checkbox";
		input.classList.add("toggle-input");

		const toggleBtn = document.createElement("div");
		toggleBtn.classList.add("toggle-container");

		const toggleTrack = document.createElement("div");
		toggleTrack.classList.add("toggle-track");

		const toggleThumb = document.createElement("div");
		toggleThumb.classList.add("toggle-thumb");

		toggleTrack.appendChild(toggleThumb);
		toggleBtn.appendChild(input);
		toggleBtn.appendChild(toggleTrack);

		return [input, toggleBtn];
	};

	const createToggleSetting = function(text, op, varSet, onSet) {
		const [input, toggleBtn] = createToggleSwitch();
		const [menuGet, menuSet, menuDefaultGet] = [`get${op}Setting`, `set${op}Setting`, `getDefault${op}Setting`];
		input.checked = menuSettings[menuGet]();

		const setter = () => {
			input.checked = !input.checked;
			menuSettings[menuSet](input.checked);

			varSet(input);
		};

		// Activation of the toggle slider
		toggleBtn.addEventListener(activator, () => {
			setter();
			onSet();
		});

		resetters.push(() => {
			input.checked = !menuSettings[menuDefaultGet](); // setter flips this from expected value
			setter();
		});

		return [createText(`${text}:`), toggleBtn];
	};

	// Let the game flip to the next card automatically or not
	menuContainer.appendChild(menuOption(createToggleSetting(
		"Auto Barajear",
		"AutoFlipMode",
		input => autoFlip = input.checked,
		() => clickAudio.play()
	)));
	
	// Seconds per baraja
	menuContainer.appendChild(menuOption((function() {
		const input = document.createElement("input");
		input.type = "number";
		input.value = dispTime / 1000;

		const setter = () => {
			menuSettings.setBarajaTimeSetting(input.value);
			dispTime = input.value * 1000;
		};

		input.addEventListener("input", setter);

		resetters.push(() => {
			input.value = menuSettings.getDefaultBarajaTimeSetting();
			setter();
		});

		return [createText("Segundos por Baraja:"), input];
	})()));

	// Play sound effects or not
	menuContainer.appendChild(menuOption(createToggleSetting(
		"Efectos de Sonido",
		"SoundEffect",
		input => audioUI.forEach(a => input.checked ? a.unmute() : a.mute()),
		() => clickAudio.play()
	)));

	// Announce a new baraja or not
	menuContainer.appendChild(menuOption(createToggleSetting(
		"Anunciar Baraja",
		"Announcement",
		input => announceBaraja = input.checked,
		() => {clickAudio.play(); synth.play("Ámonos");}
	)));

	// Vibrate phone on new card or not
	menuContainer.appendChild(menuOption(createToggleSetting(
		"Vibrar al Barajear",
		"Vibration",
		input => vibrate = input.checked,
		() => {clickAudio.play(); flipPulse();}
	)));

	// History size
	menuContainer.appendChild(menuOption((function() {
		const input = document.createElement("input");
		input.type = "number";
		input.value = historySize;
		input.min = 0;

		const setter = () => {
			menuSettings.setHistorySizeSetting(input.value);
			historySize = input.value;

			populateHistory();
		};

		input.addEventListener("input", setter);

		resetters.push(() => {
			input.value = menuSettings.getDefaultHistorySizeSetting();
			setter();
		});

		return [createText("Tamaño del Historial:"), input];
	})()));

	// Fade history out on new baraja
	menuContainer.appendChild(menuOption(createToggleSetting(
		"Desvanecer al Historial",
		"FadeHistory",
		input => fadeHistory = input.checked,
		() => clickAudio.play()
	)));

	// Reset all other settings to their default values
	menuContainer.appendChild(menuOption((function() {
		let resetTimer = 0;
		let resetting = false;

		const defaultStr = `❌ (3)`;

		const btn = document.createElement("div");
		btn.classList.add("panic-button");
		btn.appendChild(createText(defaultStr));

		const defaultBGColor = window.getComputedStyle(btn).getPropertyValue("background-color");

		const resetBtn = () => {
			btn.classList.remove("active");
			btn.children[0].innerText = defaultStr;
			btn.style.backgroundColor = defaultBGColor;
		};

		btn.addEventListener(activator, () => {
			const btnText = btn.children[0].innerText;
			const btnNum = btnText.substring(3, btnText.length - 1);

			if (btnNum.match(/^\d+$/)) {
				clearTimeout(resetTimer);

				const count = btnNum.match(/^\d+$/) ? Number.parseInt(btnNum) - 1 : 0;

				if (count <= 0) {
					btn.classList.add("active");
					btn.children[0].innerText = "❌";

					resetTimer = setTimeout(resetBtn, 7000);
				} else {
					btn.children[0].innerText = `❌ (${count})`;

					resetTimer = setTimeout(resetBtn, 3000);
				}
			} else {
				if (!resetting) {
					clearTimeout(resetTimer);

					localStorage.clear();
					resetters.forEach(r => r());
					resetting = true;

					btn.style.backgroundColor = '#046a6a';
					btn.children[0].innerText = "✔️";
					clickAudio.play();
					flipPulse();

					setTimeout(() => {
						resetBtn();
						resetting = false;
					}, 2000);
				}
			}
		});

		return [createText("Resetear Ajustes:"), btn];
	})()));

	// Add a keydown event to the window so that when spacebar is pressed, it's as if the activator was used
	window.addEventListener("keydown", e => {
		// Spacebar
		if (e.key === ' ') {
			// Prevent the default spacebar behavior of scrolling the page
			e.preventDefault();

			// Fire off the carta activator event
			carta.dispatchEvent(new Event(activator));
		}
	});

	// Make sure that the card history continues to be correctly positioned even on window resize
	window.addEventListener("resize", positionHistory);
}

</script>

</body>
</html>
